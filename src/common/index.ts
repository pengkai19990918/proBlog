export const MARKDOC =
  "用来方便使用，免去繁琐的创建过程，所以写了个脚本工具，记录下来。\n\n需求：执行 `node` 文件，在控制台输入 文章标题、文章分类、以及文件名后自动创建 `MD` 文件。实现的功能如下：\n\n![](https://github.com/gershonv/note/blob/master/assets/node-shell.gif?raw=true)\n\n创建的内容如下：\n\n```md\n---\ntitle: node\ndate: 2020-01-09 10:09:38\n---\n```\n\n路径则是 `xxx/docs/node/node.md`\n\n## 前置知识\n\n- [commander](https://github.com/tj/commander.js): 解析用户命令行输入\n- [inquirer](https://github.com/SBoudrias/Inquirer.js): 常见的交互式命令行用户界面的集合\n- [chalk](https://github.com/chalk/chalk): 美化命令行，进行着色\n\n### commander\n\n[commander](https://github.com/tj/commander.js)灵感来自 `Ruby`，它提供了用户命令行输入和参数解析的强大功能，可以帮助我们简化命令行开发。\n根据其官方的描述，具有以下特性:\n\n- 参数解析\n- 强制多态\n- 可变参数\n- Git 风格的子命令\n- 自动化帮助信息\n- 自定义帮助等\n\n**example**\n\n```js\nconst program = require('commander')\nconst inquirer = require('inquirer')\nconst chalk = require('chalk')\nprogram\n  .command('module')\n  .alias('m')\n  .description('输入名称')\n  .option('-n, --name [moduleName]', '模块名称')\n  .action(option => {\n    console.log('Hello World', option.name)\n  })\n\nprogram.parse(process.argv)\n```\n\n```js\n$ node app m -n guosw // 输出：Hello World guosw\n```\n\n**commander API**\n\n- `command` – 定义命令行指令，后面可跟上一个 `name`，用空格隔开，如 `.command( ‘app [name] ‘)`\n- `alias` – 定义一个更短的命令行指令 ，如执行命令`\\$ app m` 与之是等价的\n- `description` – 描述，它会在 `help` 里面展示\n- `option` – 定义参数。它接受四个参数，在第一个参数中，它可输入短名字 -a 和长名字–app ,使用 | 或者,分隔，在命令行里使用时，这两个是等价的，区别是后者可以在程序里通过回调获取到；第二个为描述, 会在 `help` 信息里展示出来；第三个参数为回调函数，他接收的参数为一个`string`，有时候我们需要一个命令行创建多个模块，就需要一个回调来处理；第四个参数为默认值\n- `action` – 注册一个 callback 函数,这里需注意目前回调不支持 let 声明变量\n- `parse` – 解析命令行\n\n### inquirer\n\n在开发的过程中，我们需要频繁的跟命令行进行交互，借助 `inquirer` 这个模块就能轻松实现，它提供了用户界面和查询会话流程。它的语法是这样的（直接从[官方](https://github.com/SBoudrias/Inquirer.js)拷贝~~）\n\n```js\nvar inquirer = require('inquirer')\ninquirer\n  .prompt([\n    /* Pass your questions in here */\n  ])\n  .then(function(answers) {\n    // Use user feedback for... whatever!!\n  })\n```\n\n**inquirer 功能简介**\n\n- `input` – 输入\n- `validate` – 验证\n- `list` – 列表选项\n- `confirm` – 提示\n- `checkbox` – 复选框等等\n\n**example**\n\n```js\ninquirer\n  .prompt([\n    {\n      type: 'input',\n      name: 'title',\n      message: '请输入文章标题',\n      validate: function(input) {\n        return !input ? '标题不能为空' : true\n      }\n    }\n  ])\n  .then(answers => {\n    console.log(answers) // { title: 'xxxx' }\n  })\n```\n\n## 代码\n\n```js\nconst program = require('commander')\nconst inquirer = require('inquirer') // 命令行交互\nconst fs = require('fs')\nconst path = require('path')\nconst chalk = require('chalk') // console.log color\nconst getDate = require('./getDate')\n\n// 查询目录\nconst list = fs.readdirSync('./docs') // 读取文件目录，里面还包含了文件\nconst folderList = list.filter(pathname => {\n  const filePath = path.resolve(__dirname, `../docs/${pathname}`)\n  return pathname !== '.vuepress' && fs.statSync(filePath).isDirectory()\n})\n\nprogram\n  .command('page')\n  .alias('p')\n  .description('脚本命令')\n  .option('-a, --name [moduleName]', '模块名称')\n  .action(async option => {\n    const result = await inquirer.prompt([\n      {\n        type: 'input',\n        name: 'title',\n        message: '请输入文章标题',\n        validate: function(input) {\n          return !input ? '标题不能为空' : true\n        }\n      },\n      {\n        type: 'list',\n        name: 'tag',\n        message: '请选择分类',\n        choices: folderList\n      },\n      {\n        type: 'input',\n        name: 'filename',\n        message: '请输入文件名',\n        validate: function(input) {\n          return !input ? '文件名不能为空' : true\n        }\n      }\n    ])\n\n    // 创建文件\n    const { title, tag, filename } = result\n    const filePath = path.resolve(__dirname, `../docs/${tag}/${filename}.md`)\n    const prefix = '---\\n' + `title: ${title}\\n` + `date: ${getDate()}\\n` + '---\\n'\n    fs.writeFileSync(filePath, prefix)\n    console.log(chalk.green('create page success: '), filePath)\n  })\n\nprogram.parse(process.argv)\n```\n\n命令行 `node xx.js page` 或者 `node xx.js p` 即可触发上面的命令\n\n## 参考\n\n[跟着老司机玩转 Node 命令行](https://aotu.io/notes/2016/08/09/command-line-development/index.html)\n";
